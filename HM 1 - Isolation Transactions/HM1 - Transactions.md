# Отчет по эксперименту с уровнями изоляции транзакций


  

### Начальная подготовка данных

```sql

-- Первая сессия

create  table  persons(id serial, first_name text, second_name text);

insert into persons(first_name, second_name) values('ivan', 'ivanov');

insert into persons(first_name, second_name) values('petr', 'petrov');

commit;

```

  

## Уровень изоляции по умолчанию (Read Committed)

  

### 1: Проверка текущего уровня изоляции

```sql

show transaction  isolation  level;

```

> **Результат**: `READ COMMITTED`

  

### 2: Начало транзакций

> Обе сессии начали работу с уровнем изоляции по умолчанию (READ COMMITTED)

  

### 3: Операции в первой сессии

```sql

-- Первая сессия

insert into persons(first_name, second_name) values('sergey', 'sergeev');

```

  

### 4: Проверка во второй сессии

```sql

-- Вторая сессия

select  *  from persons;

```

> **Результат**: Новая запись ('sergey', 'sergeev') ❌ НЕ видна

> **Причина**: При уровне изоляции READ COMMITTED незафиксированные изменения из других транзакций не видны

  

### 5: Фиксация первой транзакции

```sql

-- Первая сессия

commit;

```

  

### 6: Проверка во второй сессии после фиксации

```sql

-- Вторая сессия

select  *  from persons;

```

> **Результат**: Новая запись ('sergey', 'sergeev') ✅ ТЕПЕРЬ видна

> **Причина**: После фиксации первой транзакции изменения становятся видимыми для других транзакций при уровне изоляции READ COMMITTED

  

## Уровень изоляции Repeatable Read

  

### 1: Установка нового уровня изоляции

```sql

-- Обе сессии

set  transaction  isolation  level  repeatable  read;

```

  

### 2: Операции в первой сессии

```sql

-- Первая сессия

insert into persons(first_name, second_name) values('sveta', 'svetova');

```

  

### 3: Проверка во второй сессии

```sql

-- Вторая сессия

select  *  from persons;

```

> **Результат**: Новая запись ('sveta', 'svetova') ❌ НЕ видна

> **Причина**: При уровне изоляции REPEATABLE READ незафиксированные изменения из других транзакций не видны

  

### 4: Фиксация первой транзакции

```sql

-- Первая сессия

commit;

```

  

### 5: Проверка во второй сессии после фиксации

```sql

-- Вторая сессия

select  *  from persons;

```

> **Результат**: Новая запись ('sveta', 'svetova') ❌ ВСЕ ЕЩЕ НЕ видна

> **Причина**: При уровне изоляции REPEATABLE READ транзакция видит снимок данных на момент начала транзакции

  

### 6: Фиксация второй транзакции

```sql

-- Вторая сессия

commit;

```

  

### 7: Финальная проверка

```sql

-- Вторая сессия

select  *  from persons;

```

> **Результат**: Новая запись ('sveta', 'svetova') ✅ ТЕПЕРЬ видна

> **Причина**: После фиксации второй транзакции и начала новой транзакции новая запись становится видимой, так как теперь она является частью зафиксированного состояния базы данных

  

## Ключевые выводы

  

### Уровень изоляции READ COMMITTED

- Незафиксированные изменения не видны другим транзакциям

-  Изменения становятся видимыми сразу после фиксации

- Каждый запрос видит последнее зафиксированное состояние

  

### Уровень изоляции REPEATABLE READ

- Обеспечивает согласованный снимок данных

- Изменения из других транзакций не видны до завершения текущей транзакции

- Предотвращает неповторяющиеся чтения в рамках одной транзакции

- Более высокий уровень изоляции, чем READ COMMITTED

  

## Заключение

  

Эксперимент демонстрирует фундаментальные различия между уровнями изоляции READ COMMITTED и REPEATABLE READ в PostgreSQL:

  

-  **READ COMMITTED** позволяет видеть изменения из других транзакций сразу после их фиксации

-  **REPEATABLE READ** поддерживает согласованный снимок данных на протяжении всей транзакции, предотвращая фантомные чтения и обеспечивая согласованность данных в рамках транзакции
