# Отчет по эксперименту с уровнями изоляции транзакций

## Настройка эксперимента

### Начальная подготовка данных
```sql
-- Первая сессия
create table persons(id serial, first_name text, second_name text);
insert into persons(first_name, second_name) values('ivan', 'ivanov');
insert into persons(first_name, second_name) values('petr', 'petrov');
commit;
```

## Часть 1: Уровень изоляции по умолчанию (Read Committed)

### Шаг 1: Проверка текущего уровня изоляции
```sql
show transaction isolation level;
```
Результат: READ COMMITTED

### Шаг 2: Начало транзакций
Обе сессии начали работу с уровнем изоляции по умолчанию (READ COMMITTED)

### Шаг 3: Операции в первой сессии
```sql
-- Первая сессия
insert into persons(first_name, second_name) values('sergey', 'sergeev');
```

### Шаг 4: Проверка во второй сессии
```sql
-- Вторая сессия
select * from persons;
```
Результат: Новая запись ('sergey', 'sergeev') НЕ видна
Причина: При уровне изоляции READ COMMITTED незафиксированные изменения из других транзакций не видны

### Шаг 5: Фиксация первой транзакции
```sql
-- Первая сессия
commit;
```

### Шаг 6: Проверка во второй сессии после фиксации
```sql
-- Вторая сессия
select * from persons;
```
Результат: Новая запись ('sergey', 'sergeev') ТЕПЕРЬ видна
Причина: После фиксации первой транзакции изменения становятся видимыми для других транзакций при уровне изоляции READ COMMITTED

## Часть 2: Уровень изоляции Repeatable Read

### Шаг 1: Установка нового уровня изоляции
```sql
-- Обе сессии
set transaction isolation level repeatable read;
```

### Шаг 2: Операции в первой сессии
```sql
-- Первая сессия
insert into persons(first_name, second_name) values('sveta', 'svetova');
```

### Шаг 3: Проверка во второй сессии
```sql
-- Вторая сессия
select * from persons;
```
Результат: Новая запись ('sveta', 'svetova') НЕ видна
Причина: При уровне изоляции REPEATABLE READ незафиксированные изменения из других транзакций не видны

### Шаг 4: Фиксация первой транзакции
```sql
-- Первая сессия
commit;
```

### Шаг 5: Проверка во второй сессии после фиксации
```sql
-- Вторая сессия
select * from persons;
```
Результат: Новая запись ('sveta', 'svetova') ВСЕ ЕЩЕ НЕ видна
Причина: При уровне изоляции REPEATABLE READ транзакция видит снимок данных на момент начала транзакции

### Шаг 6: Фиксация второй транзакции
```sql
-- Вторая сессия
commit;
```

### Шаг 7: Финальная проверка
```sql
-- Вторая сессия
select * from persons;
```
Результат: Новая запись ('sveta', 'svetova') ТЕПЕРЬ видна
Причина: После фиксации второй транзакции и начала новой транзакции новая запись становится видимой, так как теперь она является частью зафиксированного состояния базы данных

## Ключевые выводы

1. **Уровень изоляции READ COMMITTED**:
   - Незафиксированные изменения не видны другим транзакциям
   - Изменения становятся видимыми сразу после фиксации
   - Каждый запрос видит последнее зафиксированное состояние

2. **Уровень изоляции REPEATABLE READ**:
   - Обеспечивает согласованный снимок данных
   - Изменения из других транзакций не видны до завершения текущей транзакции
   - Предотвращает неповторяющиеся чтения в рамках одной транзакции
   - Более высокий уровень изоляции, чем READ COMMITTED

## Заключение

Эксперимент демонстрирует фундаментальные различия между уровнями изоляции READ COMMITTED и REPEATABLE READ в PostgreSQL. READ COMMITTED позволяет видеть изменения из других транзакций сразу после их фиксации, в то время как REPEATABLE READ поддерживает согласованный снимок данных на протяжении всей транзакции, предотвращая фантомные чтения и обеспечивая согласованность данных в рамках транзакции. 
